#!/usr/bin/env zsh

set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
CONFIG_FILE="$SCRIPT_DIR/input/config.json"

: "${OWNER:?Set OWNER (address) globally in env}"
: "${WETH:?Set WETH (address) globally in env}"

CHAIN_ID=${CHAIN_ID:?CHAIN_ID must be set}

CHAIN_CFG=$(jq -e ".\"$CHAIN_ID\"" "$CONFIG_FILE") || { echo "No config found for chain id $CHAIN_ID in $CONFIG_FILE" >&2; exit 1 }
HAS_AGG=$(jq -r ".\"$CHAIN_ID\".aggregator // empty" "$CONFIG_FILE")
HAS_ORACLE=$(jq -r ".\"$CHAIN_ID\".oracle // empty" "$CONFIG_FILE")
AGG_SALT=$(jq -r ".\"$CHAIN_ID\".aggregatorSalt // empty" "$CONFIG_FILE")
ORACLE_SALT=$(jq -r ".\"$CHAIN_ID\".salt // empty" "$CONFIG_FILE")
AGGREGATOR=""
AGG_PREFIX="0x111111"
AGG_PREFIX_REGEX="^${AGG_PREFIX}"
ORACLE_PREFIX="0xcee000"
ORACLE_PREFIX_REGEX="^${ORACLE_PREFIX}"

# Detect broadcast flag in arguments
SHOULD_BROADCAST=0
for arg in "$@"; do
  [[ "$arg" == "--broadcast" ]] && SHOULD_BROADCAST=1
done

persist_aggregator_address() {
  local tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".aggregator = \"$AGGREGATOR\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  echo "Updated aggregator in config for chain $CHAIN_ID"
}

persist_oracle_address() {
  local tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".oracle = \"$ORACLE\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  echo "Updated oracle in config for chain $CHAIN_ID"
}

resolve_script_name() {
  local section="$1" name="$2" dir file
  dir=$([[ "$section" == "wrappers" ]] && echo "wrapper" || echo "adapter")
  file="script/${dir}/Deploy${name}.s.sol"
  [[ -f "$file" ]] || { echo "Expected script file not found: $file" >&2; exit 1; }
  echo "Deploy${name}"
}

print_deploy_aggregator_hash() {
  local output json_output hash
  local -a forge_args=()
  for arg in "$@"; do
    [[ "$arg" == "--broadcast" ]] && continue
    forge_args+=("$arg")
  done

  output=$(forge script DeployAggregator --json "${forge_args[@]}") || {
    echo "DeployAggregator failed" >&2
    exit 1
  }

  json_output=$(jq -sR 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("logs")))
    | last' <<<"$output")

  [[ -n "$json_output" && "$json_output" != "null" ]] || { echo "Unable to parse forge JSON output" >&2; exit 1; }

  hash=$(jq -r '.logs[]? | select(type=="string")' <<<"$json_output" | head -n 1)
  [[ -n "$hash" && "$hash" != "null" ]] || { echo "Unable to parse DeployAggregator hash" >&2; exit 1; }

  echo "expected prefix: $AGG_PREFIX" >&2
  echo "$hash"
}

resolve_usd_oracle_script() {
  if echo "$CHAIN_CFG" | jq -e '.env.denoms? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOracleSei"
  elif echo "$CHAIN_CFG" | jq -e '.env.feeds? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOracle"
  else
    return 1
  fi
}

print_deploy_usd_oracle_hash() {
  local oracle_script="$1"
  shift
  local output json_output hash
  local -a forge_args=()
  for arg in "$@"; do
    [[ "$arg" == "--broadcast" ]] && continue
    forge_args+=("$arg")
  done

  output=$(forge script "$oracle_script" --json "${forge_args[@]}") || {
    echo "USD oracle deployment failed" >&2
    exit 1
  }

  json_output=$(jq -sR 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("logs")))
    | last' <<<"$output")

  [[ -n "$json_output" && "$json_output" != "null" ]] || { echo "Unable to parse forge JSON output" >&2; exit 1; }

  hash=$(jq -r '.logs[]? | select(type=="string")' <<<"$json_output" | head -n 1)
  [[ -n "$hash" && "$hash" != "null" ]] || { echo "Unable to parse USD oracle hash" >&2; exit 1; }

  echo "expected prefix: $ORACLE_PREFIX" >&2
  echo "$hash"
}

deploy_core_stack() {
  echo "Deploying Aggregator: BaseCoinWrapper + MultiWrapper + OffchainOracle (chain $CHAIN_ID)"
  local output json_output
  output=$(forge script DeployAggregator --json "$@") || {
    echo "Core deployment failed" >&2
    exit 1
  }

  # forge may emit warnings and secondary JSON lines; pick the last object that contains `returns`
  json_output=$(jq -sR 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("returns")))
    | last' <<<"$output")

  [[ -n "$json_output" && "$json_output" != "null" ]] || { echo "Unable to parse forge JSON output" >&2; exit 1; }

  AGGREGATOR=$(jq -er '.returns.aggregator.value // .returns[0].value // .returns.aggregator // .returns[0]' <<<"$json_output") || { echo "Unable to parse OffchainOracle address" >&2; exit 1; }
  echo "aggregator set to $AGGREGATOR"

  [[ "$SHOULD_BROADCAST" -eq 1 ]] && persist_aggregator_address
}

deploy_usd_oracle() {
  local oracle_script

  if ! oracle_script=$(resolve_usd_oracle_script); then
    echo "No USD oracle config found for chain $CHAIN_ID; skipping"
    return
  fi

  if [[ -n "$HAS_ORACLE" && "${HAS_ORACLE:l}" =~ $ORACLE_PREFIX_REGEX ]]; then
    return
  fi
  if [[ -z "$ORACLE_SALT" ]]; then
    print_deploy_usd_oracle_hash "$oracle_script" "$@"
    exit 0
  fi

  echo "Deploying USD oracle ($oracle_script) for chain $CHAIN_ID"
  local output json_output
  output=$(forge script "$oracle_script" --json "$@") || {
    echo "USD oracle deployment failed" >&2
    exit 1
  }

  json_output=$(jq -sR 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("returns")))
    | last' <<<"$output")

  [[ -n "$json_output" && "$json_output" != "null" ]] || { echo "Unable to parse forge JSON output" >&2; exit 1; }

  ORACLE=$(jq -er '.returns.oracle.value // .returns[0].value // .returns.oracle // .returns[0]' <<<"$json_output") || { echo "Unable to parse USD oracle address" >&2; exit 1; }
  echo "USD oracle set to $ORACLE"

  [[ "$SHOULD_BROADCAST" -eq 1 ]] && persist_oracle_address
}

run_section() {
  local section="$1" # "wrappers" or "adapters"
  shift
  local forge_args=("$@")
  local entries_len
  entries_len=$(echo "$CHAIN_CFG" | jq -r ".${section} // [] | length")

  [[ "$entries_len" -eq 0 ]] && { echo "No ${section} configured for chain $CHAIN_ID"; return; }

  for ((i=0; i<entries_len; i++)); do
    local name script addr
    name=$(echo "$CHAIN_CFG" | jq -r ".${section}[$i].name")
    addr=$(echo "$CHAIN_CFG" | jq -r ".${section}[$i].env.address // empty")

    if [[ -n "$addr" ]]; then
      if [[ "$section" == "wrappers" ]]; then
        script="AddWrapperFromConfig"
      else
        script="AddOracleFromConfig"
      fi
      echo "Using existing $section -> $name ($addr) via $script"
    else
      script=$(resolve_script_name "$section" "$name")
      echo "Running $section -> $name ($script)"
    fi

    if ! env "INDEX=$i" forge script "$script" "${forge_args[@]}"; then
      echo "Error running $section/$name ($script); aborting." >&2
      exit 1
    fi
  done
}

if [[ "$HAS_AGG" =~ $AGG_PREFIX_REGEX ]]; then
  deploy_usd_oracle "$@"
  echo "Done for chain $CHAIN_ID"
  exit 0
fi

if [[ -z "$AGG_SALT" ]]; then
  print_deploy_aggregator_hash "$@"
  exit 0
fi

deploy_core_stack "$@"
run_section "wrappers" "$@"
run_section "adapters" "$@"
deploy_usd_oracle "$@"

echo "Done for chain $CHAIN_ID"
