#!/usr/bin/env zsh

set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
CONFIG_FILE="$SCRIPT_DIR/../config.json"

# print all oracles:
jq -r 'to_entries[] | "\(.key):\t\(.value.oracle)"' $CONFIG_FILE

CHAIN_ID=${CHAIN_ID:?CHAIN_ID must be set}

AGG_PREFIX="0x111111"
ORACLE_PREFIX="0xcee000"

# Detect flags in arguments
SHOULD_BROADCAST=0
for arg in "$@"; do
  [[ "$arg" == "--broadcast" ]] && SHOULD_BROADCAST=1
done

log_err() {
  echo "$@" >&2
}
cfg_get() {
  jq -r ".\"$CHAIN_ID\".${1} // empty" "$CONFIG_FILE"
}

update_config_value() {
  local cfg_path="$1" value="$2" tmp
  tmp=$(mktemp)
  jq --indent 4 --arg value "$value" ".\"$CHAIN_ID\".${cfg_path} = \$value" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
}

CHAIN_CFG=$(jq -e ".\"$CHAIN_ID\"" "$CONFIG_FILE") || { echo "No config found for chain id $CHAIN_ID in $CONFIG_FILE" >&2; exit 1 }
HAS_AGG=$(cfg_get "aggregator")
HAS_ORACLE=$(cfg_get "oracle")
AGG_SALT=$(cfg_get "aggregatorSalt")
ORACLE_SALT=$(cfg_get "salt")

print_step() {
  local label="$1"
  echo "$label"
}

print_separator() {
  local icon="$1" label="${2:-}"
  local line="----------------------------------------"
  echo
  if [[ -n "$label" ]]; then
    echo "${icon} ${line}"
    echo "${icon} ${label}"
    echo "${icon} ${line}"
  else
    echo "${icon} ${line}"
  fi
}

mine_create2_salt() {
  local prefix="$1" hash="$2"
  local output salt err_file
  err_file=$(mktemp)

  if ! output=$(cast create2 -s "$prefix" --init-code-hash "$hash" 2>"$err_file"); then
    log_err "cast create2 failed: $(<"$err_file")"
    rm -f "$err_file"
    exit 1
  fi
  rm -f "$err_file"

  salt=$(awk '/^Salt:/ {print $2; exit}' <<<"$output")
  [[ -n "$salt" && "$salt" != "null" ]] || {
    echo "Unable to parse salt from cast create2 output" >&2
    exit 1
  }

  echo "$salt"
}

run_forge_json() {
  local out_file err_file
  out_file=$(mktemp)
  err_file=$(mktemp)
  if ! forge script --json "$@" >"$out_file" 2>"$err_file"; then
    cat "$err_file" >&2
    rm -f "$err_file" "$out_file"
    return 1
  fi
  rm -f "$err_file"
  echo "$out_file"
}

run_forge_json_or_die() {
  local label="$1"
  shift
  local output_file
  output_file=$(run_forge_json "$@") || {
    log_err "$label"
    exit 1
  }
  echo "$output_file"
}

extract_hash_from_logs() {
  local output_file="$1"
  jq -sRr 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("logs")))
    | last
    | .logs[]? | select(type=="string")' "$output_file" | grep -m1 -oE '0x[0-9a-fA-F]{64}'
}

extract_return_value() {
  local output_file="$1" jq_expr="$2"
  jq -sRer "split(\"\n\")
    | map(try fromjson catch empty)
    | map(select(type==\"object\" and has(\"returns\")))
    | last
    | ${jq_expr}" "$output_file"
}

resolve_adapter_script() {
  local name="$1" file
  file="script/adapter/Deploy${name}.s.sol"
  [[ -f "$file" ]] || { echo "Expected script file not found: $file" >&2; exit 1; }
  echo "Deploy${name}"
}

resolve_usd_oracle_script() {
  if echo "$CHAIN_CFG" | jq -e '.env.denoms? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOracleSei"
  elif echo "$CHAIN_CFG" | jq -e '.env.pyths? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOraclePyth"
  elif echo "$CHAIN_CFG" | jq -e '.env.feeds? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOracle"
  else
    return 1
  fi
}

print_deploy_hash() {
  local script="$1" label="$2"
  shift 2
  local output_file hash
  local -a args=()
  local arg
  for arg in "$@"; do
    [[ "$arg" == "--broadcast" ]] && continue
    args+=("$arg")
  done
  output_file=$(run_forge_json "$script" "${args[@]}") || {
    log_err "$label"
    exit 1
  }

  hash=$(extract_hash_from_logs "$output_file")
  rm -f "$output_file"
  [[ -n "$hash" && "$hash" != "null" ]] || { log_err "Unable to parse ${script} hash"; exit 1; }

  echo "$hash"
}

deploy_core_stack() {
  print_separator "ðŸš€" "Core deployment"
  print_step "aggregator deploy"
  local output_file aggregator
  output_file=$(run_forge_json_or_die "Core deployment failed" DeployAggregator "$@")

  # forge may emit warnings and secondary JSON lines; pick the last object that contains `returns`
  aggregator=$(extract_return_value "$output_file" '(.returns.aggregator.value // .returns[0].value // .returns.aggregator // .returns[0])') || {
      rm -f "$output_file"
      log_err "Unable to parse OffchainOracle address"
      exit 1
    }
  rm -f "$output_file"
  echo "$aggregator"

  [[ "$SHOULD_BROADCAST" -eq 1 ]] && update_config_value "aggregator" "$aggregator"
}

deploy_usd_oracle() {
  local oracle_script

  if ! oracle_script=$(resolve_usd_oracle_script); then
    return
  fi

  if [[ -n "$HAS_ORACLE" && "${HAS_ORACLE:l}" == ${ORACLE_PREFIX}* ]]; then
    return
  fi
  print_separator "ðŸ’µ" "USD oracle"
  if [[ -z "$ORACLE_SALT" ]]; then
    local hash
    hash=$(print_deploy_hash "$oracle_script" "USD oracle deployment failed" "$@")
    ORACLE_SALT=$(mine_create2_salt "$ORACLE_PREFIX" "$hash")
    update_config_value "salt" "$ORACLE_SALT"
  fi

  print_step "usd_oracle deploy"
  local output_file
  output_file=$(run_forge_json_or_die "USD oracle deployment failed" "$oracle_script" "$@")

  ORACLE=$(extract_return_value "$output_file" '(.returns.oracle.value // .returns[0].value // .returns.oracle // .returns[0])') || {
      rm -f "$output_file"
      log_err "Unable to parse USD oracle address"
      exit 1
    }
  rm -f "$output_file"
  echo "$ORACLE"

  [[ "$SHOULD_BROADCAST" -eq 1 ]] && update_config_value "oracle" "$ORACLE"
}

run_adapters() {
  local forge_args=("$@")
  local entries_len
  entries_len=$(echo "$CHAIN_CFG" | jq -r ".adapters // [] | length")

  [[ "$entries_len" -eq 0 ]] && return
  print_separator "ðŸ§©" "Adapters"

  for ((i=0; i<entries_len; i++)); do
    local name script addr display_name
    name=$(echo "$CHAIN_CFG" | jq -r ".adapters[$i].name")
    display_name=$(echo "$CHAIN_CFG" | jq -r ".adapters[$i].env.name // .adapters[$i].label // .adapters[$i].name")

    addr=$(echo "$CHAIN_CFG" | jq -r ".adapters[$i].env.address // empty")

    if [[ -n "$addr" ]]; then
      script="AddOracleFromConfig"
      print_step "$display_name ($name)"
    else
      script=$(resolve_adapter_script "$name")
      print_step "$display_name ($name)"
    fi

    local output_file
    output_file=$(INDEX=$i run_forge_json_or_die "Error running adapters/$name ($script); aborting." "$script" "${forge_args[@]}")

    if [[ -n "$addr" ]]; then
      rm -f "$output_file"
      echo "$addr"
      continue
    fi

    local deployed_addr
    deployed_addr=$(extract_return_value "$output_file" '(.returns.oracle.value // .returns.wrapper.value // .returns[0].value // .returns.oracle // .returns.wrapper // .returns[0])') || {
      rm -f "$output_file"
      log_err "Unable to parse deployed adapter address"
      exit 1
    }
    rm -f "$output_file"

    echo "$deployed_addr"

    if [[ "$SHOULD_BROADCAST" -eq 1 ]]; then
      update_config_value "adapters[$i].env.address" "$deployed_addr"
    fi
  done
}

if [[ "$HAS_AGG" == ${AGG_PREFIX}* ]]; then
  deploy_usd_oracle "$@"
  exit 0
fi

if [[ -z "$AGG_SALT" ]]; then
  hash=$(print_deploy_hash "DeployAggregator" "DeployAggregator failed" "$@")
  AGG_SALT=$(mine_create2_salt "$AGG_PREFIX" "$hash")
  if [[ "$SHOULD_BROADCAST" -eq 1 ]]; then
    update_config_value "aggregatorSalt" "$AGG_SALT"
  fi
fi

deploy_core_stack "$@"
run_adapters "$@"
deploy_usd_oracle "$@"

exit 0
