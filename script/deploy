#!/usr/bin/env zsh

set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
CONFIG_FILE="$SCRIPT_DIR/input/config.json"

: "${OWNER:?Set OWNER (address) globally in env}"
: "${WETH:?Set WETH (address) globally in env}"

CHAIN_ID=${CHAIN_ID:?CHAIN_ID must be set}

CHAIN_CFG=$(jq -e ".\"$CHAIN_ID\"" "$CONFIG_FILE") || { echo "No config found for chain id $CHAIN_ID in $CONFIG_FILE" >&2; exit 1 }
HAS_AGG=$(jq -r ".\"$CHAIN_ID\".aggregator // empty" "$CONFIG_FILE")
HAS_ORACLE=$(jq -r ".\"$CHAIN_ID\".oracle // empty" "$CONFIG_FILE")
AGG_SALT=$(jq -r ".\"$CHAIN_ID\".aggregatorSalt // empty" "$CONFIG_FILE")
ORACLE_SALT=$(jq -r ".\"$CHAIN_ID\".salt // empty" "$CONFIG_FILE")
AGGREGATOR=""
AGG_PREFIX="0x111111"
AGG_PREFIX_REGEX="^${AGG_PREFIX}"
ORACLE_PREFIX="0xcee000"
ORACLE_PREFIX_REGEX="^${ORACLE_PREFIX}"
STEP_ICON_LEFT="ðŸ”¹====================="
STEP_ICON_RIGHT="===================== ðŸ”¹"

# Detect flags in arguments
SHOULD_BROADCAST=0
for arg in "$@"; do
  [[ "$arg" == "--broadcast" ]] && SHOULD_BROADCAST=1
done

log_info() {
  echo "$@"
}

log_err() {
  echo "$@" >&2
}

persist_aggregator_address() {
  local tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".aggregator = \"$AGGREGATOR\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  log_info "Updated aggregator in config for chain $CHAIN_ID"
}

persist_oracle_address() {
  local tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".oracle = \"$ORACLE\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  log_info "Updated oracle in config for chain $CHAIN_ID"
}

persist_aggregator_salt() {
  local tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".aggregatorSalt = \"$AGG_SALT\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  log_info "Updated aggregatorSalt in config for chain $CHAIN_ID"
}

persist_oracle_salt() {
  local tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".salt = \"$ORACLE_SALT\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  log_info "Updated salt in config for chain $CHAIN_ID"
}

persist_adapter_address() {
  local index="$1" addr="$2" tmp
  tmp=$(mktemp)
  jq --indent 4 ".\"$CHAIN_ID\".adapters[$index].env.address = \"$addr\"" "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
  log_info "Updated adapter env.address in config for chain $CHAIN_ID (index $index)"
}

print_step() {
  local label="$1"
  echo ""
  echo "${STEP_ICON_LEFT} ${label} ${STEP_ICON_RIGHT}"
}

mine_create2_salt() {
  local prefix="$1" hash="$2"
  local output salt err_file
  err_file=$(mktemp)

  if ! output=$(cast create2 -s "$prefix" --init-code-hash "$hash" 2>"$err_file"); then
    log_err "cast create2 failed: $(<"$err_file")"
    rm -f "$err_file"
    exit 1
  fi
  rm -f "$err_file"

  salt=$(awk '/^Salt:/ {print $2; exit}' <<<"$output")
  [[ -n "$salt" && "$salt" != "null" ]] || {
    echo "Unable to parse salt from cast create2 output" >&2
    exit 1
  }

  echo "$salt"
}

resolve_script_name() {
  local section="$1" name="$2" dir file
  dir=$([[ "$section" == "wrappers" ]] && echo "wrapper" || echo "adapter")
  file="script/${dir}/Deploy${name}.s.sol"
  [[ -f "$file" ]] || { echo "Expected script file not found: $file" >&2; exit 1; }
  echo "Deploy${name}"
}

print_deploy_aggregator_hash() {
  local output_file hash
  local -a forge_args=()
  for arg in "$@"; do
    [[ "$arg" == "--broadcast" ]] && continue
    forge_args+=("$arg")
  done

  output_file=$(run_forge_json DeployAggregator "${forge_args[@]}") || {
    log_err "DeployAggregator failed"
    exit 1
  }

  hash=$(jq -sRr 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("logs")))
    | last
    | .logs[]? | select(type=="string")' "$output_file" | grep -m1 -oE '0x[0-9a-fA-F]{64}')
  rm -f "$output_file"
  [[ -n "$hash" && "$hash" != "null" ]] || { log_err "Unable to parse DeployAggregator hash"; exit 1; }

  echo "$hash"
}

resolve_usd_oracle_script() {
  if echo "$CHAIN_CFG" | jq -e '.env.denoms? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOracleSei"
  elif echo "$CHAIN_CFG" | jq -e '.env.feeds? // empty | length > 0' >/dev/null; then
    echo "DeployUsdOracle"
  else
    return 1
  fi
}

print_deploy_usd_oracle_hash() {
  local oracle_script="$1"
  shift
  local output_file hash
  local -a forge_args=()
  for arg in "$@"; do
    [[ "$arg" == "--broadcast" ]] && continue
    forge_args+=("$arg")
  done

  output_file=$(run_forge_json "$oracle_script" "${forge_args[@]}") || {
    log_err "USD oracle deployment failed"
    exit 1
  }

  hash=$(jq -sRr 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("logs")))
    | last
    | .logs[]? | select(type=="string")' "$output_file" | grep -m1 -oE '0x[0-9a-fA-F]{64}')
  rm -f "$output_file"
  [[ -n "$hash" && "$hash" != "null" ]] || { log_err "Unable to parse USD oracle hash"; exit 1; }

  echo "$hash"
}

deploy_core_stack() {
  print_step "Deploying Aggregator: BaseCoinWrapper + MultiWrapper + OffchainOracle (chain $CHAIN_ID)"
  local output_file
  output_file=$(run_forge_json DeployAggregator "$@") || {
    log_err "Core deployment failed"
    exit 1
  }

  # forge may emit warnings and secondary JSON lines; pick the last object that contains `returns`
  AGGREGATOR=$(jq -sRer 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("returns")))
    | last
    | (.returns.aggregator.value // .returns[0].value // .returns.aggregator // .returns[0])' "$output_file") || {
      rm -f "$output_file"
      log_err "Unable to parse OffchainOracle address"
      exit 1
    }
  rm -f "$output_file"
  log_info "aggregator set to $AGGREGATOR"

  [[ "$SHOULD_BROADCAST" -eq 1 ]] && persist_aggregator_address
}

deploy_usd_oracle() {
  local oracle_script

  if ! oracle_script=$(resolve_usd_oracle_script); then
    log_info "No USD oracle config found for chain $CHAIN_ID; skipping"
    return
  fi

  if [[ -n "$HAS_ORACLE" && "${HAS_ORACLE:l}" =~ $ORACLE_PREFIX_REGEX ]]; then
    return
  fi
  if [[ -z "$ORACLE_SALT" ]]; then
    local hash
    hash=$(print_deploy_usd_oracle_hash "$oracle_script" "$@")
    ORACLE_SALT=$(mine_create2_salt "$ORACLE_PREFIX" "$hash")
    persist_oracle_salt
  fi

  print_step "Deploying USD oracle ($oracle_script) for chain $CHAIN_ID"
  local output_file
  output_file=$(run_forge_json "$oracle_script" "$@") || {
    log_err "USD oracle deployment failed"
    exit 1
  }

  ORACLE=$(jq -sRer 'split("\n")
    | map(try fromjson catch empty)
    | map(select(type=="object" and has("returns")))
    | last
    | (.returns.oracle.value // .returns[0].value // .returns.oracle // .returns[0])' "$output_file") || {
      rm -f "$output_file"
      log_err "Unable to parse USD oracle address"
      exit 1
    }
  rm -f "$output_file"
  log_info "USD oracle set to $ORACLE"

  [[ "$SHOULD_BROADCAST" -eq 1 ]] && persist_oracle_address
}

run_section() {
  local section="$1" # "wrappers" or "adapters"
  shift
  local forge_args=("$@")
  local entries_len
  entries_len=$(echo "$CHAIN_CFG" | jq -r ".${section} // [] | length")

  [[ "$entries_len" -eq 0 ]] && { log_info "No ${section} configured for chain $CHAIN_ID"; return; }

  for ((i=0; i<entries_len; i++)); do
    local name script addr label
    name=$(echo "$CHAIN_CFG" | jq -r ".${section}[$i].name")
    addr=$(echo "$CHAIN_CFG" | jq -r ".${section}[$i].env.address // empty")

    if [[ -n "$addr" ]]; then
      if [[ "$section" == "wrappers" ]]; then
        script="AddWrapperFromConfig"
      else
        script="AddOracleFromConfig"
      fi
      label="Using existing $section -> $name ($addr) via $script"
    else
      script=$(resolve_script_name "$section" "$name")
      label="Deploying $section -> $name ($script)"
    fi

    print_step "$label"

    if [[ -n "$addr" ]]; then
      local output_file
      output_file=$(INDEX=$i run_forge_json "$script" "${forge_args[@]}") || {
        log_err "Error running $section/$name ($script); aborting."
        exit 1
      }
      rm -f "$output_file"
    else
      local output_file deployed_addr
      output_file=$(INDEX=$i run_forge_json "$script" "${forge_args[@]}") || {
        log_err "Error running $section/$name ($script); aborting."
        exit 1
      }

      deployed_addr=$(jq -sRer 'split("\n")
        | map(try fromjson catch empty)
        | map(select(type=="object" and has("returns")))
        | last
        | (.returns.oracle.value // .returns.wrapper.value // .returns[0].value // .returns.oracle // .returns.wrapper // .returns[0])' "$output_file") || {
          rm -f "$output_file"
          log_err "Unable to parse deployed $section address"
          exit 1
        }
      rm -f "$output_file"

      log_info "$section -> $name set to $deployed_addr"

      if [[ "$section" == "adapters" && "$SHOULD_BROADCAST" -eq 1 ]]; then
        persist_adapter_address "$i" "$deployed_addr"
      fi
    fi
  done
}

run_forge_json() {
  local out_file err_file
  out_file=$(mktemp)
  err_file=$(mktemp)
  if ! forge script --json "$@" >"$out_file" 2>"$err_file"; then
    cat "$err_file" >&2
    rm -f "$err_file" "$out_file"
    return 1
  fi
  rm -f "$err_file"
  echo "$out_file"
}

if [[ "$HAS_AGG" =~ $AGG_PREFIX_REGEX ]]; then
  deploy_usd_oracle "$@"
  log_info "Done for chain $CHAIN_ID"
  exit 0
fi

if [[ -z "$AGG_SALT" ]]; then
  hash=$(print_deploy_aggregator_hash "$@")
  AGG_SALT=$(mine_create2_salt "$AGG_PREFIX" "$hash")
  persist_aggregator_salt
fi

deploy_core_stack "$@"
run_section "wrappers" "$@"
run_section "adapters" "$@"
deploy_usd_oracle "$@"

log_info "Done for chain $CHAIN_ID"
